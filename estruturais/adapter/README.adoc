:imagesdir: ../../images/patterns/estruturais
:source-highlighter: highlightjs
:numbered:
:unsafe:
:icons: font

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

= Padr√µes de Projetos Estruturais

== Adapter (Adaptador)

IMPORTANT: https://youtu.be/G4Objgc6zxM[V√≠deo-aula sobre o padr√£o.]

.https://youtu.be/45I9jX5uO9A
https://youtu.be/45I9jX5uO9A[image:adapter-tomada.png[]]


=== Defini√ß√£o

// tag::definicao[]
üìò"O padr√£o adapter converte a interface de uma classe em outra interface que os clientes esperam. **Um adaptador permite que classes anteriormente incompat√≠veis possam trabalhar em conjunto**". <<UCPP>>
// end::definicao[]

=== Aplicabilidade

Um dos casos onde o adapter √© amplamente aplicado √© quando utiliza-se um determinado servi√ßo web, framework ou biblioteca (que chamaremos de componente) onde existem diferentes implementa√ß√µes destes, cada uma funcionando de uma forma diferente. Logo, o c√≥digo necess√°rio para usar um determinado componente seria diferente de outro. Normalmente v√£o existir v√°rios m√©todos com nomes e par√¢metros diferentes (assinaturas). Assim, trocar tal componente por outro pode ser um trabalho complexo. 

Um adapter neste caso pode fornecer uma interface padr√£o a ser utilizada publicamente, encapsulando as diferen√ßas entre as diferentes implementa√ß√µes dos componentes e permitindo a substitui√ß√£o de um componente por outro.

Voc√™ tamb√©m pode precisar fornecer um componente existente para ser utilizado por uma outra empresa, mas seu componente tem uma interface p√∫blica diferente do que tal empresa exige. Isto ocorre por exemplo, em sistemas de pagamento online disponibilizados por diversas empresas. Para que o seu sistema seja notificado se um pagamento foi confirmado, ele precisa fornecer um servi√ßo com uma determinada interface. Assim, o sistema de pagamento interage com tal interface para notificar o seu sistema da confirma√ß√£o do pagamento de um cliente. Alguns exemplos incluem o servi√ßo do https://m.pagseguro.uol.com.br/v2/guia-de-integracao/api-de-notificacoes.html?_rnt=dd#v2-item-servico-de-notificacoes[PagSeguro] e PayPal.

=== Modelagem do Padr√£o

.Modelagem do padr√£o adapter
image::adapter.png[]

Podemos ter 1 ou mais classes que precisam ser adaptadas, como as classes `AdaptadaAbc` e `AdaptadaXyz`.
Cada uma dessas classes fornece uma implementa√ß√£o diferente de uma determinada funcionalidade.
Por exemplo, cada classe pode representar o acesso a um determinado servi√ßo na web,
como obten√ß√£o da previs√£o do tempo. Cada uma obt√©m a previs√£o de um servi√ßo (site) diferente.
Podemos ter v√°rios m√©todos diferentes que fornecem as mesmas funcionalidades, como obten√ß√£o da previs√£o para uma determinada data, m√©dia de temperatura para um determinado m√™s do ano, umidade relativa do ar, etc. No entanto, os m√©todos, par√¢metros e tipos em cada uma dessas classes (como possivelmente foram implementadas por pessoas/equipes distintas), ser√£o diferentes. 

Para padronizarmos tais m√©todos e assim tornar id√™ntica a forma de usar qualquer uma dessas classes, devemos implementar um adaptador para cada classe a ser adaptada. No diagrama de exemplo, a classe `AdaptadaAbc` possui os m√©todos `metodoA()` e `metodoB()`. J√° a  classe `AdaptadaXyz` possui os m√©todos `metodoX()` e `metodoY()`. A padroniza√ß√£o pode ser feita pela cria√ß√£o de uma interface comum (`Alvo`) que ser√° implementada por cada adaptador. O nome de cada classe Adapter normalmente √© formado pelo nome da classe a ser adaptada, seguido da palavra `Adapter`. Assim, temos as classes `AbcAdapter` e `XyzAdapter` para o modelo apresentado. Uma classe `AbcAdapter` que implementa a interface `Alvo` √© um adaptador para a classe `AdaptadaAbc`. Em outras palavras, ela adapta objetos `AdaptadaAbc` para funcionarem como se fossem do tipo `Alvo`.

`Cliente` √© uma classe qualquer que vai usar esta interface para se comunicar com os objetos adaptados por meio de seus adaptadores.
Assim, se a classe `Cliente` precisar trocar um objeto por outro, como o objeto ser√° acessado por meio da interface `Alvo`, n√£o precisaremos alterar a forma de utilizar um novo objeto.

Observe que, por exemplo, o `metodo1()` na classe `AbcAdapter` vai apenas delegar a chamada ao `metodoA()` de um objeto `AbcAdapter`.

Um projeto de exemplo para o diagrama apresentado est√° dispon√≠vel link:modelagem[aqui]. Ele deve ser alterado para incluir as mudan√ßas necess√°rias para o problema espec√≠fico que voc√™ estiver resolvendo com o padr√£o.

Voc√™ pode entender melhor o diagrama da Figura 1 fazendo uma analogia com o adaptador de tomada como a Figura 2 abaixo.

.Analogia da Modelagem do Padr√£o Adapter com um Adaptador de Tomada
image::adapter-analogia-tomada.png[]

=== Exemplos Pr√°ticos

.Modelagem fict√≠cia de adaptadores para sistemas de pagamento online
image::sistemas-pagamento-adapters.png[]

A gera√ß√£o de n√∫meros aleat√≥rios utilizando servi√ßos web como http://random.org e http://random.irb.hr tamb√©m √© outro exemplo onde adapters podem ser criados.
Tais servi√ßos geram n√∫meros verdadeiramente aleat√≥rios usando, por exemplo, dados meteorol√≥gicos.
No entanto, cada servi√ßo implementa uma API diferente, com par√¢metros e tipos de retorno distintos.
Para trocar um servi√ßo por outro em uma aplica√ß√£o, √© preciso alterar o c√≥digo
da aplica√ß√£o por causa das diferen√ßas na API.

=== Princ√≠pios utilizados

- https://en.wikipedia.org/wiki/Single_responsibility_principle[Single Responsibility Principle (SRP)] pois cada adaptador criado possui uma responsabilidade √∫nica: tornar uma classe a ser adaptada compat√≠vel com a interface alvo.
- https://en.wikipedia.org/wiki/Open‚Äìclosed_principle[Open/Closed Principle (OCP)], pois se uma nova classe precisar ser adaptada, basta criar um novo adaptador implementando a interface alvo. N√£o precisamos alterar nenhum c√≥digo existente.
- https://en.wikipedia.org/wiki/Liskov_substitution_principle[Liskov Substitution Principle (LSP)] pois em qualquer lugar que a interface alvo puder ser usada, podemos usar um adaptador pra qualquer uma das classes adaptadas. A Figura 4 mostra como o princ√≠pio se aplica.
- https://en.wikipedia.org/wiki/Dependency_inversion_principle[Dependency Inversion Principle (DIP)]: ao usar somente a interface alvo para declarar vari√°veis e n√£o as classes adaptadas, passamos a depender de uma abstra√ß√£o e n√£o de implementa√ß√µes. Com isto, os relacionamentos de depend√™ncia s√£o invertidos: no lugar de o cliente depender de cada uma das implementa√ß√µes, ele depende apenas do tipo abstrato (a interface alvo). O cliente nem precisa saber da exist√™ncia das classes concretas. Reveja a Figura 1 para entender o relacionamento de depend√™ncia.
- https://tuhrig.de/programming-to-an-interface/[Programar para uma interface n√£o uma implementa√ß√£o] (GoF): como o c√≥digo do cliente vai depender apenas da interface alvo, estaremos "programando para uma interface, n√£o uma implementa√ß√£o".

.Princ√≠pio LSP com o padr√£o Adapter: se tivermos um adaptador para cada um dos diferentes tipos de plug, podemos usar qualquer um deles com uma tomada espec√≠fica.
image::adapter-analogia-varios.png[]

== Padr√µes Relacionados

- Decorator

== Onde o padr√£o √© usado no JDK e outros lugares

No JDK, apesar de n√£o estar expl√≠cito pelo nome, temos adapters implementados como m√©todos. Exemplos incluem: 

- `java.util.Arrays#asList()`: a partir de um array, retorna uma nova inst√¢ncia de um adaptador para List.
- `java.util.Collections#list()`: a partir de uma cole√ß√£o qualquer como conjuntos (Set), filas (Queue), 
- https://docs.oracle.com/javase/8/javafx/api/javafx/beans/property/adapter/package-summary.html[um pacote inteiro de adapters para aplica√ß√µes Desktop com JavaFX]

Bibliotecas para gera√ß√£o de logs em aplica√ß√µes s√£o um exemplo onde o Adapter e outros padr√µes (como o Facade) s√£o usados.
Voc√™ pode nunca ter usado uma biblioteca destas em Java ou qualquer linguagem, mas pode ter certeza que
precisar√°. Log √© um recurso essencial em qualquer aplica√ß√£o rodando em produ√ß√£o.

A https://docs.oracle.com/javase/7/docs/api/java/util/logging/Logger.html[java.util.logging (JUL)] √© um dos casos onde uma biblioteca fornecida pelo JDK possui recursos limitados e outras surgiram justamente para resolver tais problemas, como a https://logging.apache.org/log4j/[Apache Log4J]. Existem algumas outras bibliotecas de log para Java, mas incompat√≠veis entre si. 
Por esta causa, o adaptador https://logging.apache.org/log4j/log4j-2.7/log4j-jul/index.html[Apache Log4J JUL Adapter] permite utilizar a Log4J no lugar da JUL, sem precisar alterar o c√≥digo da aplica√ß√£o.

== Exerc√≠cios

=== Cota√ß√µes de Empresas da Bolsa de Valores

Veja o projeto base e informa√ß√µes em link:cotacao-bolsa-valores[cotacao-bolsa-valores].

=== Adaptando a aplica√ß√£o de consulta de CEP (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/quarkus-cep-services/tree/master/cep-service-producer[zip])

Voltando ao https://github.com/manoelcampos/quarkus-cep-services/tree/master/cep-service-producer[projeto que utiliza servi√ßos de consulta de CEP] dispon√≠veis na web, cada servi√ßo retorna um objeto endere√ßo em um formato diferente do outro, como pode verificar nestes links para o https://viacep.com.br/ws/01001000/json/[ViaCep] e o https://api.postmon.com.br/v1/cep/77021090[Postmon].

Como o problema aqui √© referente ao formato dos dados, precisamos apena adapter os dados para um formato comum.
Assim, a implementa√ß√£o n√£o precisa seguir a modelagem apresentada na Figura 1 acima.
Uma solu√ß√£o simples, que n√£o requer a cria√ß√£o de classes adapters, √© apresentada abaixo.
Voc√™ precisar√° fazer o processamento manual do c√≥digo JSON recebido
pelo servi√ßo, que representa o endere√ßo de um determinado CEP.
Para isso, podemos usar a biblioteca https://javaee.github.io/jsonp/getting-started.html[JSON-P (JSON Processing)] da plataforma Java para o Quarkus, adicionando a depend√™ncia a seguir no pom.xml:

[source,xml]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-jsonp</artifactId>
      <version>${quarkus.version}</version>
    </dependency>
----

//No JavaEE tradicional as depend√™ncias s√£o javax.json/javax.json-api e org.glassfish/javax.json

Voc√™ pode usar um c√≥digo como abaixo para fazer o tal processamento:

[source,java]
----
JsonReader reader = Json.createReader(new StringReader(json));
JsonObject object = reader.readObject();
Endereco endereco = new Endereco();
endereco.setLogradouro(object.getString("logradouro"));
----

Alternativamente, veja o projeto link:cep-service-adapter-automatico[cep-service-adapter-automatico], 
que apenas usa recursos da biblioteca https://github.com/FasterXML/jackson[Jackson] e assim n√£o requer a implementa√ß√£o do padr√£o Adapter.

=== Pensando em interfaces como adaptadores

Em um classe que implementa m√∫ltiplas interfaces, podemos pensar na classe como sendo um adaptador para todas estas interfaces. Apesar de nem sempre o padr√£o Adapter est√° sendo de fato implementado nestes casos, ao pensar assim, podemos ter alguns benef√≠cios.

Na Java Collections Framework (JCF), classes como ArrayList e LinkedList funcionam como adaptadores para a interface List. Assim, no lugar de declarar os tipos concretos, usamos a interface List no lugar. Assim, em qualquer lugar que for exigido uma List, podemos passar um "adaptador" como ArrayList ou LinkedList. Internamente, estas classes podem ter m√©todos com nomes e assinaturas diferentes, mas como elas implementam os m√©todos de List, as diferen√ßas internas s√£o encapsuladas.
Por exemplo, na classe ArrayList utiliza-se `elementData(index)` para acessar um elemento 
em uma determinada posi√ß√£o. Na classe LinkedList utiliza-se `node(index).item`.
Mesmo as duas classes fazerem parte da mesma framework (a JCF), elas representam estruturas
de dados muito diferentes. Para tornar seu uso uniforme para n√≥s desenvolvedores, 
os m√©todos citados n√£o s√£o p√∫blicos. Temos o `public E get(int index)` em tais classes,
que √© herdado da interface `List`. Tal m√©todo padroniza o acesso aos elementos.

Classes como ArrayList e LinkedList implementam m√∫ltiplas interfaces em uma hierarquia como List -> Collection -> Iterable. Tal hierarquia nos permite usar um ArrayList como se fosse um objeto List, Collection ou Iterable, de acordo com suas necessidades.

Como exemplo, veja o seguinte m√©todo com uma implementa√ß√£o n√£o ideal:

[source,java]
----
private void imprimir(ArrayList<Double> elementos){
    for (Double e : elementos) {
        System.out.println(e);
    }

    elementos.clear();
}
----

Como pode ver, o m√©todo recebe um ArrayList, imprime todos os valores e apaga seus elementos.
Pense em como podemos criar 3 diferentes vers√µes deste m√©todo para:

1. imprimir qualquer tipo de lista (ArrayList, LinkedList, etc)
2. impedir que a lista seja modificada (por exemplo, pela remo√ß√£o de elementos)
3. imprimir qualquer tipo de cole√ß√£o (ArrayList, LinkedList, HashSet, TreeSet, etc)

TIP: Analise a √°rvore hierarquica dos tipos mencionados e quais m√©todos p√∫blicos eles fornecem para resolver os 3 problemas acima. Voc√™ come√ßar analisando a hierarquia da classe https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html[ArrayList em sua documenta√ß√£o].
