:imagesdir: ../../images/patterns/criacionais
:source-highlighter: highlightjs
:numbered:
:unsafe:
:icons: font

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

= Padr√µes de Projetos Criacionais

IMPORTANT: https://www.youtube.com/playlist?list=PLyo0RUAM69UtO8Jjq71qgvRxcI2pTrB2m[V√≠deo-aulas dispon√≠veis aqui.]

== Simple Factory (F√°brica Simples)

=== Defini√ß√£o

üìòSimple Factory permite encapsular a cria√ß√£o de objetos em uma classe que representa uma f√°brica.
Ela n√£o √© de fato um padr√£o de projeto, podendo ser definida como um modelo para a cria√ß√£o de objetos.

=== Aplicabilidade

Sabemos que para instanciar objetos em Java e outras linguagens √© utilizado o operador `new`.
Apesar de podermos declarar uma vari√°vel com um tipo abstrato, ao instanciar um objeto para tal vari√°vel,
estamos definindo explicitamente qual tipo concreto ser√° usado. 

Se existir uma l√≥gica que define qual tipo concreto ser√° utilizado em um determinado momento e tivermos que 
utilizar esta l√≥gica em diversas partes do c√≥digo quando precisarmos instanciar um objeto, podemos utilizar
a Simple Factory para encapsular a cria√ß√£o destes objetos. Com isto, evitamos de duplicar esta l√≥gica em 
v√°rios locais do projeto. 
Esta l√≥gica normalmente √© definida por um bloco de `if()` que define as condi√ß√µes para a cria√ß√£o dos objetos.

Adicionalmente, considere que temos um tipo abstrato/super-tipo (classe abstrata ou interface) e v√°rias sub-classes que podem ser instanciados.
Se utilizarmos `new` para instanciar uma determinada sub-classe em diferentes locais do sistema e precisarmos
substituir estas inst√¢ncias por uma sub-classe diferente, ter√≠amos que fazer isso manualmente alterando 
os v√°rios locais no c√≥digo. Utilizando a Simple Factory, a cria√ß√£o de objetos de uma determinada sub-classe
fica encapsulada e centralizada em um m√©todo da Simple Factory.

=== Modelagem

A Simple Factory pode ser modelada como demonstrado no diagrama a seguir.

.Modelagem da Simple Factory
image::simple-factory.png[]

Teremos uma classe `SimpleFactory` que voc√™ deve dar um nome apropriado.
Alguns exemplos incluem:

- `SimplePizzaFactory` ou `PizzaFactory` para criar pizzas;
- `SimpleProdutoFactory` ou `ProdutoFactory` para criar produtos.

`Cliente` √© uma classe qualquer que precisa utilizar objetos produzidos pela Factory. 
Assim, podemos ter v√°rias classes clientes.

NOTE: O termo "cliente", amplamente utilizado quando falamos de padr√µes de projeto e POO, representa uma classe que usa os servi√ßos de outra classe, como uma pessoa que usa os servi√ßos de uma empresa.

O `TipoAbstrato` √© um super tipo representado por uma **interface** ou **classe abstrata**. 
Como ele √© abstrato, a Factory criar√° objetos de algum dos sub-tipos dispon√≠veis,
de acordo com uma poss√≠vel l√≥gica que voc√™ definir.

Os m√©todos `newObject` da `SimpleFactory` retornam um `TipoAbstrato`, mas internamente 
criam um objeto de algum dos sub-tipos existentes. Este m√©todo √© normalmente definido como est√°tico,
assim, n√£o temos que instanciar a f√°brica para depois podermos instanciar os objetos que queremos.
Observe que pode haver duas vers√µes de tal m√©todo. A vers√£o que n√£o recebe par√¢metros normalmente vai
sempre retornar um tipo espec√≠fico de objeto. Ao usar tal m√©todo em v√°rias partes do sistema,
se precisarmos trocar qual o tipo de objeto a ser instanciado, temos que apenas alterar este m√©todo.
Os locais onde ele estava sendo usado n√£o sofrem nenhuma altera√ß√£o.

A outra vers√£o do m√©todo que possui par√¢metros (cujo quantidade e tipos depende do seu problema)
normalmente vai permitir, ao desenvolvedor que for usar a Factory, informar qual objeto
a ser criado e poss√≠veis dados a serem usados para cri√°-lo, sem especificar
qual classe ser√° instanciada. Adicionalmente, se existir uma determinada l√≥gica necess√°ria
para criar qualquer dos tipos de objeto poss√≠veis, tal l√≥gica ficar√° encapsulada
dentro destes m√©todos `newObject`. Qualquer altera√ß√£o neste l√≥gica precisar√° ser feita
em apenas um local.

Um projeto de exemplo para o diagrama apresentado est√° dispon√≠vel link:modelagem[aqui]. Ele deve ser alterado para incluir as mudan√ßas necess√°rias para o problema espec√≠fico que voc√™ estiver resolvendo com o padr√£o.

=== Princ√≠pios utilizados

==== Open-Closed Principle

Com o https://en.wikipedia.org/wiki/Open‚Äìclosed_principle[Open/Closed Principle (OCP)], separamos as partes que mudam, i.e. a l√≥gica de cria√ß√£o de objetos, de dentro da classe que utiliza tais objetos. Isto torna a classe que utiliza a factory "aberta para extens√£o e fechada para modifica√ß√£o".

==== Programar para uma "interface" n√£o uma implementa√ß√£o

https://tuhrig.de/programming-to-an-interface/[Programar para uma "interface" n√£o uma implementa√ß√£o] (GoF) indica que devemos declar vari√°veis com tipos abstratos (`TipoAbstrato`) e usar tipos concretos apenas na instancia√ß√£o (`SubTipo1` ... `SubTipoN`).

==== Dependency Inversion Principle (DIP)

Ao aplicar o https://en.wikipedia.org/wiki/Dependency_inversion_principle[Dependency Inversion Principle (DIP)], a classe cliente que utiliza a factory n√£o depende mais de tipos concretos, mas sim de tipos abstratos (interfaces ou classes abstratas).
Se *n√£o* utiliz√°ssemos a Simple Factory, a classe cliente seria respons√°vel pela l√≥gica de cria√ß√£o dos objetos,
dependendo de cada um dos objetos que pode criar, como mostra o diagrama a seguir.

.Depend√™ncias com a N√ÉO utiliza√ß√£o da Simple Factory
image::no-simple-factory.png[]

Se observarmos a Figura 1 na Se√ß√£o 1.3, podemos ver que a classe `Cliente` depende da `SimpleFactory`, que depende do `TipoAbstrato`. 
Como `Cliente` usar√° objetos do `TipoAbstrato`, ele depende de tal tipo. Ent√£o, podemos esquecer a `SimpleFactory` por um momento e visualizar esta depend√™ncia como no diagrama a seguir.

.Depend√™ncia com a utiliza√ß√£o da Simple Factory: classe Cliente depende de TipoAbstrato
image::simple-factory-dip.png[]

Comparando a Figura 2 com a 3, podemos ver que a rela√ß√£o de depend√™ncia foi invertida. A classe `Cliente` deixou de depender de tipos concretos e passou a depender de um tipo abstrato.

=== Exemplos

Podemos utilizar a Simple Factory para definir qual estrat√©gia de leitura de arquivo de retorno de boleto banc√°rio
ser√° utilizada. Assim, n√£o teremos que manualmente decidir qual estrat√©gia instanciar cada vez que
precisarmos ler arquivos de retorno. 
Baseado no projeto link:../../comportamentais/template-method/retorno-boleto-template-funcional[retorno-boleto-template-funcional], vamos implementar a Simple Factory.

Implemente o projeto seguindo a modelagem abaixo:

.Simple Factory para a instancia√ß√£o de estrat√©gias de processamento de arquivos de retorno de boleto banc√°rio.
image::simple-factory-boleto-funcional.png[]

O c√≥digo fonte do projeto est√° dispon√≠vel link:retorno-boleto-simple-factory-funcional[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/criacionais/simple-factory/retorno-boleto-simple-factory-funcional[zip]).
Uma implementa√ß√£o alternativa, que n√£o utiliza programa√ß√£o funcional e descobre dinamicamente o nome da
classe para leitura do arquivo de retorno informado pode ser vista link:retorno-boleto-simple-factory-dynamic[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/criacionais/simple-factory/retorno-boleto-simple-factory-dynamic[zip]).
Veja a documenta√ß√£o no link acima para detalhes do projeto.

=== Detalhes de Implementa√ß√£o

A forma mais f√°cil de implementar a Simple Factory, como apresentado na Figura 1, √© definir o m√©todo `newObject` na classe `SimpleFactory` como est√°tico. 
Assim, n√£o √© preciso instanciar uma f√°brica para depois criar objetos, basta chamar o m√©todo diretamente da classe
fazendo `SimpleFactory.newObject()`. Isto torna o uso da f√°brica mais f√°cil.
Se a f√°brica n√£o armazena nenhum atributo, pode n√£o haver uma raz√£o espec√≠fica para exigir que ela seja instanciada
para podermos chamar seus m√©todos. √â apenas preciso ter em mente que ao declarar o m√©todo como est√°tico,
ele n√£o poder√° ser modificado em poss√≠veis sub-classes. Se n√£o pretende fazer override do m√©todo, n√£o h√° problema.

O m√©todo `newObject` tamb√©m pode receber par√¢metros para definir qual e/ou como um objeto ser√° criado.
O nome do m√©todo tamb√©m deve ser definido adequadamente, como `newPizza()`, `newProduto()`, etc.

== Padr√µes Relacionados

Padr√µes que possuem similaridades ou podem ser usados em conjunto:

- link:../../comportamentais/template-method[Template Method]

== Onde o padr√£o √© usado no JDK

=== Calendar

A classe `Calendar` no JDK √© abstrata, logo, n√£o pode ser instanciada. 
Existem diferentes tipos de calend√°rio que podem ser instanciados, de acordo 
com a regi√£o geogr√°fica definida para o sistema (`Locale`).
O m√©todo `getInstance()` ent√£o √© respons√°vel por definir qual subclasse de `Calendar`
ser√° usada para instanciar um calend√°rio.

Ele utiliza o m√©todo auxiliar `createCalendar` para isto. Como falado
anteriormente, neste caso o m√©todo possui par√¢metros para definir como criar o objeto.
Note que dentro do m√©todo ele define diferentes tipos de calend√°rio, como gregorianos (o nosso), japon√™s e budista.

=== JCF no JDK 9+

A partir do JDK 9, as classes Collection introduziram os chamados
"Factory Methods". Apesar do nome ser o de outro padr√£o que veremos
√† frente, tal padr√£o n√£o √© implementado aqui. O que temos √© simplesmente
uma Simple Fatory.

A express√£o *Factory Method* express√£o √© confusa pois pode se referir √†:

- um padr√£o com este mesmo nome (n√£o √© o caso), que veremos a seguir;
- ou simplesmente a um *m√©todo f√°brica* em uma classe/interface respons√°vel por instanciar objetos.
  Qualquer tipo de f√°brica ter√° um m√©todo f√°brica.

[source, java]
----
List<String> listaNomes = List.of("Minha", "Lista", "de", "Strings");
----

[source, java]
----
Map<String, Integer> mapaHabitantesCidade = 
                        Map.of("Palmas", 217000, "Gurupi", 84000);
----

=== Falando de JDK, pula pro JDK 10

[source, java]
----
var listaNomes = List.of("Minha", "Lista", "de", "Strings");
var listaPares = List.of(2, 4, 6);
var mapaHabitantesCidade = Map.of("Palmas", 217000, "Gurupi", 84000);
----

== Exerc√≠cios

pass:[<a name="exportador"></a>]

=== Exporta√ß√£o de dados

Implemente um conjunto de classes que recebe uma lista de produtos e permite exportar tais produtos em diferentes formatos como Tabela HTML, CSV, tabela Markdown. Utilize a diagrama de classes abaixo como base para sua implementa√ß√£o. Tenha em mente que um diagrama desses pode apresentar os detalhes mais importantes como m√©todos e atributos que j√° se sabe previamente. No entanto, durante o desenvolvimento, pode-se
perceber que s√£o necess√°rios mais m√©todos e/ou atributos. O diagrama apresenta apenas os elementos p√∫blicos e protegidos.
Novos m√©todos que precisem ser inclu√≠dos, que ser√£o usados pelos apresentados, normalmente s√£o privados,
exatamente por serem apenas m√©todos auxiliares que n√£o fazem sentido serem chamados de fora das classes.

.Diagrama de classes para implementa√ß√£o do exportador de lista de produtos para HTML e Markdown
image::exportador-simple-factory.png[]

Observe que neste caso, n√£o temos uma classe espec√≠fica para a Simple Factory.
Temos apenas os m√©todos est√°ticos `newInstance()` na interface `ExportadorListaProdutos`
que instanciam objetos da pr√≥pria classe. Esta √© a mesma modelagem utilizada pela classe `Calendar`
do JDK. M√©todos est√°ticos em interfaces √© um dos recursos do Java 8.

NOTE: Existem in√∫meras bibliotecas que realizam tal tarefa, mas o objetivo aqui √© praticar. Se precisar realmente exportar dados em qualquer formato, tente utilizar uma biblioteca existente. Pode-se exportar dados em XML e JSON utilizando bibliotecas padr√µes do JDK.

O c√≥digo fonte do projeto est√° dispon√≠vel link:exportador-simple-factory[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/criacionais/simple-factory/exportador-simple-factory[zip]), mas tente primeiro implementar antes de ver o projeto.

=== Tornando a exporta√ß√£o de dados gen√©rica

O projeto anterior permite exportar apenas uma lista de produtos. Se precisarmos exportar outros dados como clientes ou vendas, teremos que criar um novo conjunto de classes para cada tipo de objeto que queremos exportar. Isto √© bastante trabalhoso e repetitivo.
Neste projeto vamos usar __Reflection__, um recurso avan√ßado da linguagem Java, com o Simple Factory para conseguir exportar qualquer dado em qualquer formato implementado.

O c√≥digo fonte do projeto est√° dispon√≠vel link:exportador-simple-factory-reflection[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/criacionais/simple-factory/exportador-simple-factory-reflection[zip]), mas tente primeiro implementar antes de ver o projeto.
